{
  "_args": [
    [
      "queue2@~0.1.0",
      "/Users/sid/Desktop/webpack/node_modules/kat"
    ]
  ],
  "_from": "queue2@>=0.1.0 <0.2.0",
  "_id": "queue2@0.1.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/queue2",
  "_npmUser": {
    "email": "roly426@gmail.com",
    "name": "fent"
  },
  "_npmVersion": "1.2.14",
  "_phantomChildren": {},
  "_requested": {
    "name": "queue2",
    "raw": "queue2@~0.1.0",
    "rawSpec": "~0.1.0",
    "scope": null,
    "spec": ">=0.1.0 <0.2.0",
    "type": "range"
  },
  "_requiredBy": [
    "/kat"
  ],
  "_resolved": "https://registry.npmjs.org/queue2/-/queue2-0.1.0.tgz",
  "_shasum": "76abaa4c6bd66f5853936aa9188983cd107a76f9",
  "_shrinkwrap": null,
  "_spec": "queue2@~0.1.0",
  "_where": "/Users/sid/Desktop/webpack/node_modules/kat",
  "author": {
    "name": "Roly Fentanes",
    "url": "https://github.com/fent"
  },
  "bugs": {
    "url": "https://github.com/fent/queue2.js/issues"
  },
  "dependencies": {},
  "description": "A unordered queue and ordered queue working together.",
  "devDependencies": {
    "mocha": "*"
  },
  "directories": {},
  "dist": {
    "shasum": "76abaa4c6bd66f5853936aa9188983cd107a76f9",
    "tarball": "http://registry.npmjs.org/queue2/-/queue2-0.1.0.tgz"
  },
  "homepage": "https://github.com/fent/queue2.js#readme",
  "keywords": [
    "concurrency",
    "ordered",
    "queue"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/fent/queue2.js/raw/master/LICENSE"
    }
  ],
  "main": "./lib/index.js",
  "maintainers": [
    {
      "name": "fent",
      "email": "roly426@gmail.com"
    }
  ],
  "name": "queue2",
  "optionalDependencies": {},
  "readme": "# queue2 [![Build Status](https://secure.travis-ci.org/fent/queue2.js.png)](http://travis-ci.org/fent/queue2.js)\n\nA queue with a unique use case.\n\n\n# Motive\nI created this queue data structure because of the unique use case I ran into. I needed to open files in an asynchronous way, to maximize efficiency. But I needed to read from them in order, including subdirectories. This queue helped me do that, although for now I can't think of other use cases for this.\n\nI've also tried to think of a way to simplify this and possibly break it down into 2 type of queues. But since both workers depend on each other and share the same concurrency, I'm starting to think this is what the simplified solution is.\n\n\n# API\n\n### new Queue2(worker1, worker2, concurrency)\n\nCreates a queue with the given workers and concurrency. Jobs will be executed asynchronously with no more than `concurrency` running at once. `worker1` will be alled the arguments which `Queue2#push()` was called with plus a callback function that should be called with either an error or results when the task finishes.\n\n```js\nfunction worker1(a, b, c, callback) {\n  someAsyncOp(a, b, c, callback);\n}\n```\n\nThe `worker1` function is also called with a context which contains a method named `inject` for placing additional tasks in place, in the same position, of the current running task. The context also includes an `injected` key which will be `true` if the current task was added using the `inject` function.\n\n```js\nfunction worker1(a, b, c, callback) {\n  this.inject([\n    [1, 2, 3],\n    [2, 3, 4],\n    [3, 4, 5]\n  ]);\n}\n```\n\nThe `callback` should not be called when `inject` is used. Since the tasks injected are supposed to replace the current one.\n\n### Queue2#push(arg1, arg2, arg3...)\n\nPushes a task onto the queue. If the last argument is a function and it corresponds with the position of the callback from the first worker, then it will be called once there is an error with the task, or the task finishes.\n\nFor example:\n\n```js\nvar q = new Queue2(function worker1(a, callback) {\n  // a === 1\n  callback(null);\n}, worker2);\n\nq.push(1, function(err) {\n if (err) throw err;\n\n // will be called once this finishes\n});\n\nq.push(1);\n```\n\n### Queue#active\n\nNumber of active tasks that are running.\n\n### Queue2#die()\n\nKills the queue.\n\n### Event: 'full'\n\nQueue is full.\n\n### Event: 'empty'\n\nQueue is empty, with tasks still running.\n\n### Event: 'drain'\n\nQueue is empty and tasks have finished.\n\n\n# Install\n\n    npm install queue2\n\n\n# Tests\nTests are written with [mocha](http://visionmedia.github.com/mocha/)\n\n```bash\nnpm test\n```\n\n# License\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/fent/queue2.js.git"
  },
  "scripts": {
    "test": "mocha -R spec test/*-test.js"
  },
  "version": "0.1.0"
}
